import * as Micro from 'effect/Micro';
import { process } from 'std-env';
import { lookup, mimeTypes } from '@uploadthing/mime-types';
import * as Predicate from 'effect/Predicate';
import * as Context from 'effect/Context';
import { pipe } from 'effect/Function';
import * as Either from 'effect/Either';
import * as Encoding from 'effect/Encoding';

const ValidContentDispositions = [
    "inline",
    "attachment"
];
const ValidACLs = [
    "public-read",
    "private"
];

class InvalidRouteConfigError extends /** #__PURE__ */ Micro.TaggedError("InvalidRouteConfig") {
    constructor(type, field){
        const reason = field ? `Expected route config to have a ${field} for key ${type} but none was found.` : `Encountered an invalid route config during backfilling. ${type} was not found.`;
        super({
            reason
        });
    }
}
class UnknownFileTypeError extends /** #__PURE__ */ Micro.TaggedError("UnknownFileType") {
    constructor(fileName){
        const reason = `Could not determine type for ${fileName}`;
        super({
            reason
        });
    }
}
class InvalidFileTypeError extends /** #__PURE__ */ Micro.TaggedError("InvalidFileType") {
    constructor(fileType, fileName){
        const reason = `File type ${fileType} not allowed for ${fileName}`;
        super({
            reason
        });
    }
}
class InvalidFileSizeError extends /** #__PURE__ */ Micro.TaggedError("InvalidFileSize") {
    constructor(fileSize){
        const reason = `Invalid file size: ${fileSize}`;
        super({
            reason
        });
    }
}
class InvalidURLError extends /** #__PURE__ */ Micro.TaggedError("InvalidURL") {
    constructor(attemptedUrl){
        super({
            reason: `Failed to parse '${attemptedUrl}' as a URL.`
        });
    }
}
class RetryError extends /** #__PURE__ */ Micro.TaggedError("RetryError") {
}
class FetchError extends /** #__PURE__ */ Micro.TaggedError("FetchError") {
}
class InvalidJsonError extends /** #__PURE__ */ Micro.TaggedError("InvalidJson") {
}
class BadRequestError extends /** #__PURE__ */ Micro.TaggedError("BadRequestError") {
    getMessage() {
        if (Predicate.isRecord(this.json)) {
            if (typeof this.json.message === "string") return this.json.message;
        }
        return this.message;
    }
}
class UploadAbortedError extends /** #__PURE__ */ Micro.TaggedError("UploadAborted") {
}

function isRouteArray(routeConfig) {
    return Array.isArray(routeConfig);
}
function getDefaultSizeForType(fileType) {
    if (fileType === "image") return "4MB";
    if (fileType === "video") return "16MB";
    if (fileType === "audio") return "8MB";
    if (fileType === "blob") return "8MB";
    if (fileType === "pdf") return "4MB";
    if (fileType === "text") return "64KB";
    return "4MB";
}
/**
 * This function takes in the user's input and "upscales" it to a full config
 * Additionally, it replaces numbers with "safe" equivalents
 *
 * Example:
 * ```ts
 * ["image"] => { image: { maxFileSize: "4MB", limit: 1 } }
 * ```
 */ const fillInputRouteConfig = (routeConfig)=>{
    // If array, apply defaults
    if (isRouteArray(routeConfig)) {
        return Micro.succeed(routeConfig.reduce((acc, fileType)=>{
            acc[fileType] = {
                // Apply defaults
                maxFileSize: getDefaultSizeForType(fileType),
                maxFileCount: 1,
                minFileCount: 1,
                contentDisposition: "inline"
            };
            return acc;
        }, {}));
    }
    // Backfill defaults onto config
    const newConfig = {};
    for (const key of objectKeys(routeConfig)){
        const value = routeConfig[key];
        if (!value) return Micro.fail(new InvalidRouteConfigError(key));
        const defaultValues = {
            maxFileSize: getDefaultSizeForType(key),
            maxFileCount: 1,
            minFileCount: 1,
            contentDisposition: "inline"
        };
        newConfig[key] = {
            ...defaultValues,
            ...value
        };
    }
    // we know that the config is valid, so we can stringify it and parse it back
    // this allows us to replace numbers with "safe" equivalents
    return Micro.succeed(JSON.parse(JSON.stringify(newConfig, safeNumberReplacer)));
};
const getTypeFromFileName = (fileName, allowedTypes)=>{
    const mimeType = lookup(fileName);
    if (!mimeType) {
        if (allowedTypes.includes("blob")) return Micro.succeed("blob");
        return Micro.fail(new UnknownFileTypeError(fileName));
    }
    // If the user has specified a specific mime type, use that
    if (allowedTypes.some((type)=>type.includes("/"))) {
        if (allowedTypes.includes(mimeType)) {
            return Micro.succeed(mimeType);
        }
    }
    // Otherwise, we have a "magic" type eg. "image" or "video"
    const type = mimeType.toLowerCase() === "application/pdf" ? "pdf" : mimeType.split("/")[0];
    if (!allowedTypes.includes(type)) {
        // Blob is a catch-all for any file type not explicitly supported
        if (allowedTypes.includes("blob")) {
            return Micro.succeed("blob");
        } else {
            return Micro.fail(new InvalidFileTypeError(type, fileName));
        }
    }
    return Micro.succeed(type);
};
function generateUploadThingURL(path) {
    let host = "https://api.uploadthing.com";
    if (process.env.CUSTOM_INFRA_URL) {
        host = process.env.CUSTOM_INFRA_URL;
    }
    return `${host}${path}`;
}
const FILESIZE_UNITS = [
    "B",
    "KB",
    "MB",
    "GB"
];
const fileSizeToBytes = (fileSize)=>{
    const regex = new RegExp(`^(\\d+)(\\.\\d+)?\\s*(${FILESIZE_UNITS.join("|")})$`, "i");
    // make sure the string is in the format of 123KB
    const match = fileSize.match(regex);
    if (!match) {
        return Micro.fail(new InvalidFileSizeError(fileSize));
    }
    const sizeValue = parseFloat(match[1]);
    const sizeUnit = match[3].toUpperCase();
    const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));
    return Micro.succeed(Math.floor(bytes));
};
const bytesToFileSize = (bytes)=>{
    if (bytes === 0 || bytes === -1) {
        return "0B";
    }
    const i = Math.floor(Math.log(bytes) / Math.log(1000));
    return `${(bytes / Math.pow(1000, i)).toFixed(2)}${FILESIZE_UNITS[i]}`;
};
async function safeParseJSON(input) {
    if (typeof input === "string") {
        try {
            return JSON.parse(input);
        } catch (err) {
            console.error(`Error parsing JSON, got '${input}'`);
            return new Error(`Error parsing JSON, got '${input}'`);
        }
    }
    const text = await input.text();
    try {
        return JSON.parse(text ?? "null");
    } catch (err) {
        console.error(`Error parsing JSON, got '${text}'`);
        return new Error(`Error parsing JSON, got '${text}'`);
    }
}
/** typesafe Object.keys */ function objectKeys(obj) {
    return Object.keys(obj);
}
/** checks if obj is a valid, non-null object */ function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function asArray(val) {
    return Array.isArray(val) ? val : [
        val
    ];
}
/** construct content-disposition header */ function contentDisposition(contentDisposition, fileName) {
    return [
        contentDisposition,
        `filename="${encodeURI(fileName)}"`,
        `filename*=UTF-8''${encodeURI(fileName)}`
    ].join("; ");
}
function semverLite(required, toCheck) {
    // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`
    const semverRegex = /(\d+)\.?(\d+)?\.?(\d+)?/;
    const requiredMatch = required.match(semverRegex);
    if (!requiredMatch?.[0]) {
        throw new Error(`Invalid semver requirement: ${required}`);
    }
    const toCheckMatch = toCheck.match(semverRegex);
    if (!toCheckMatch?.[0]) {
        throw new Error(`Invalid semver to check: ${toCheck}`);
    }
    const [_1, rMajor, rMinor, rPatch] = requiredMatch;
    const [_2, cMajor, cMinor, cPatch] = toCheckMatch;
    if (required.startsWith("^")) {
        // Major must be equal, minor must be greater or equal
        if (rMajor !== cMajor) return false;
        if (rMinor > cMinor) return false;
        return true;
    }
    if (required.startsWith("~")) {
        // Major must be equal, minor must be equal
        if (rMajor !== cMajor) return false;
        if (rMinor !== cMinor) return false;
        return true;
    }
    // Exact match
    return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;
}
const getFullApiUrl = (maybeUrl)=>Micro.gen(function*() {
        const base = (()=>{
            if (typeof window !== "undefined") return window.location.origin;
            if (process.env?.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
            return "http://localhost:3000";
        })();
        const url = yield* Micro.try({
            try: ()=>new URL(maybeUrl ?? "/api/uploadthing", base),
            catch: ()=>new InvalidURLError(maybeUrl ?? "/api/uploadthing")
        });
        if (url.pathname === "/") {
            url.pathname = "/api/uploadthing";
        }
        return url;
    });
/*
 * Returns a full URL to the dev's uploadthing endpoint
 * Can take either an origin, or a pathname, or a full URL
 * and will return the "closest" url matching the default
 * `<VERCEL_URL || localhost>/api/uploadthing`
 */ const resolveMaybeUrlArg = (maybeUrl)=>{
    return maybeUrl instanceof URL ? maybeUrl : Micro.runSync(getFullApiUrl(maybeUrl));
};
/**
 * Replacer for JSON.stringify that will replace numbers that cannot be
 * serialized to JSON with "reasonable equivalents".
 *
 * Infinity and -Infinity are replaced by MAX_SAFE_INTEGER and MIN_SAFE_INTEGER
 * NaN is replaced by 0
 *
 */ const safeNumberReplacer = (_, value)=>{
    if (typeof value !== "number") return value;
    if (Number.isSafeInteger(value) || value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {
        return value;
    }
    if (value === Infinity) return Number.MAX_SAFE_INTEGER;
    if (value === -Infinity) return Number.MIN_SAFE_INTEGER;
    if (Number.isNaN(value)) return 0;
};

const ALLOWED_FILE_TYPES = [
    "image",
    "video",
    "audio",
    "pdf",
    "text",
    "blob"
];

const ERROR_CODES = {
    // Generic
    BAD_REQUEST: 400,
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    INTERNAL_SERVER_ERROR: 500,
    INTERNAL_CLIENT_ERROR: 500,
    // S3 specific
    TOO_LARGE: 413,
    TOO_SMALL: 400,
    TOO_MANY_FILES: 400,
    KEY_TOO_LONG: 400,
    // UploadThing specific
    URL_GENERATION_FAILED: 500,
    UPLOAD_FAILED: 500,
    MISSING_ENV: 500,
    FILE_LIMIT_EXCEEDED: 500
};
function messageFromUnknown(cause, fallback) {
    if (typeof cause === "string") {
        return cause;
    }
    if (cause instanceof Error) {
        return cause.message;
    }
    if (cause && typeof cause === "object" && "message" in cause && typeof cause.message === "string") {
        return cause.message;
    }
    return fallback ?? "An unknown error occurred";
}
class UploadThingError extends Micro.Error {
    constructor(initOpts){
        const opts = typeof initOpts === "string" ? {
            code: "INTERNAL_SERVER_ERROR",
            message: initOpts
        } : initOpts;
        const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);
        super({
            message
        });
        this._tag = "UploadThingError";
        this.name = "UploadThingError";
        this.code = opts.code;
        this.data = opts.data;
        if (opts.cause instanceof Error) {
            this.cause = opts.cause;
        } else if (isObject(opts.cause) && typeof opts.cause.status === "number" && typeof opts.cause.statusText === "string") {
            this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);
        } else if (typeof opts.cause === "string") {
            this.cause = new Error(opts.cause);
        } else {
            this.cause = opts.cause;
        }
    }
    static toObject(error) {
        return {
            code: error.code,
            message: error.message,
            data: error.data
        };
    }
    static serialize(error) {
        return JSON.stringify(UploadThingError.toObject(error));
    }
}
function getErrorTypeFromStatusCode(statusCode) {
    for (const [code, status] of Object.entries(ERROR_CODES)){
        if (status === statusCode) {
            return code;
        }
    }
    return "INTERNAL_SERVER_ERROR";
}
function getStatusCodeFromError(error) {
    return ERROR_CODES[error.code] ?? 500;
}
const INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new UploadThingError({
        code: "INTERNAL_CLIENT_ERROR",
        message: "Something went wrong. Please report this to UploadThing.",
        cause: e
    });

class FetchContext extends /** #__PURE__ */ Context.Tag("uploadthing/FetchContext")() {
}
// Temporary Effect wrappers below.
// TODO should be refactored with much love
// TODO handle error properly
const fetchEff = (input, init)=>Micro.flatMap(Micro.service(FetchContext), ({ fetch, baseHeaders })=>{
        const headers = new Headers(init?.headers ?? []);
        for (const [key, value] of Object.entries(baseHeaders)){
            if (typeof value === "string") headers.set(key, value);
        }
        const reqInfo = {
            url: input.toString(),
            method: init?.method,
            body: init?.body,
            headers: Object.fromEntries(headers)
        };
        return Micro.tryPromise({
            try: (signal)=>fetch(input, {
                    ...init,
                    headers,
                    signal
                }),
            catch: (error)=>new FetchError({
                    error: error instanceof Error ? {
                        ...error,
                        name: error.name,
                        message: error.message,
                        stack: error.stack
                    } : error,
                    input: reqInfo
                })
        }).pipe(Micro.map((res)=>Object.assign(res, {
                requestUrl: reqInfo.url
            })), Micro.withTrace("fetch"));
    });
const parseResponseJson = (res)=>Micro.tryPromise({
        try: async ()=>{
            const json = await res.json();
            return {
                json,
                ok: res.ok,
                status: res.status
            };
        },
        catch: (error)=>new InvalidJsonError({
                error,
                input: res.requestUrl
            })
    }).pipe(Micro.filterOrFail(({ ok })=>ok, ({ json, status })=>new BadRequestError({
            status,
            message: `Request to ${res.requestUrl} failed with status ${status}`,
            json
        })), Micro.map(({ json })=>json), Micro.withTrace("parseJson"));
const parseRequestJson = (req)=>Micro.tryPromise({
        try: ()=>req.json(),
        catch: (error)=>new InvalidJsonError({
                error,
                input: req.url
            })
    }).pipe(Micro.withTrace("parseRequestJson"));
/**
 * Schedule that retries with exponential backoff, up to 1 minute.
 * 10ms * 4^n, where n is the number of retries.
 */ const exponentialDelay = ()=>pipe(Micro.scheduleExponential(10, 4), Micro.scheduleWithMaxDelay(1000), Micro.scheduleWithMaxElapsed(60_000));

const generateMimeTypes = (typesOrRouteConfig)=>{
    const fileTypes = Array.isArray(typesOrRouteConfig) ? typesOrRouteConfig : objectKeys(typesOrRouteConfig);
    if (fileTypes.includes("blob")) return [];
    return fileTypes.map((type)=>{
        if (type === "pdf") return "application/pdf";
        if (type.includes("/")) return type;
        return [
            // Add wildcard to support all subtypes, e.g. image => "image/*"
            `${type}/*`,
            // But some browsers/OSes don't support it, so we'll also dump all the mime types
            // we know that starts with the type, e.g. image => "image/png, image/jpeg, ..."
            ...objectKeys(mimeTypes).filter((t)=>t.startsWith(type))
        ].join(", ");
    });
};
const generateClientDropzoneAccept = (fileTypes)=>{
    const mimeTypes = generateMimeTypes(fileTypes);
    return Object.fromEntries(mimeTypes.map((type)=>[
            type,
            []
        ]));
};
function getFilesFromClipboardEvent(event) {
    const dataTransferItems = event.clipboardData?.items;
    if (!dataTransferItems) return;
    const files = Array.from(dataTransferItems).reduce((acc, curr)=>{
        const f = curr.getAsFile();
        return f ? [
            ...acc,
            f
        ] : acc;
    }, []);
    return files;
}
/**
 * Shared helpers for our premade components that's reusable by multiple frameworks
 */ const generatePermittedFileTypes = (config)=>{
    const fileTypes = config ? objectKeys(config) : [];
    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];
    return {
        fileTypes,
        multiple: maxFileCount.some((v)=>v && v > 1)
    };
};
const capitalizeStart = (str)=>{
    return str.charAt(0).toUpperCase() + str.slice(1);
};
const INTERNAL_doFormatting = (config)=>{
    if (!config) return "";
    const allowedTypes = objectKeys(config);
    const formattedTypes = allowedTypes.map((f)=>f === "blob" ? "file" : f);
    // Format multi-type uploader label as "Supports videos, images and files";
    if (formattedTypes.length > 1) {
        const lastType = formattedTypes.pop();
        return `${formattedTypes.join("s, ")} and ${lastType}s`;
    }
    // Single type uploader label
    const key = allowedTypes[0];
    const formattedKey = formattedTypes[0];
    const { maxFileSize, maxFileCount, minFileCount } = config[key];
    if (maxFileCount && maxFileCount > 1) {
        if (minFileCount > 1) {
            return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;
        } else {
            return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;
        }
    } else {
        return `${formattedKey} (${maxFileSize})`;
    }
};
const allowedContentTextLabelGenerator = (config)=>{
    return capitalizeStart(INTERNAL_doFormatting(config));
};
const styleFieldToClassName = (styleField, args)=>{
    if (typeof styleField === "string") return styleField;
    if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "string") return result;
    }
    return "";
};
const styleFieldToCssObject = (styleField, args)=>{
    if (typeof styleField === "object") return styleField;
    if (typeof styleField === "function") {
        const result = styleField(args);
        if (typeof result === "object") return result;
    }
    return {};
};
const contentFieldToContent = (contentField, arg)=>{
    if (!contentField) return null;
    if (typeof contentField !== "function") return contentField;
    if (typeof contentField === "function") {
        const result = contentField(arg);
        return result;
    }
};

const signaturePrefix = "hmac-sha256=";
const algorithm = {
    name: "HMAC",
    hash: "SHA-256"
};
const signPayload = async (payload, secret)=>{
    const encoder = new TextEncoder();
    const signingKey = await crypto.subtle.importKey("raw", encoder.encode(secret), algorithm, false, [
        "sign"
    ]);
    const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then((arrayBuffer)=>Encoding.encodeHex(new Uint8Array(arrayBuffer)));
    return `${signaturePrefix}${signature}`;
};
const verifySignature = async (payload, signature, secret)=>{
    const sig = signature?.slice(signaturePrefix.length);
    if (!sig) return false;
    const encoder = new TextEncoder();
    const signingKey = await crypto.subtle.importKey("raw", encoder.encode(secret), algorithm, false, [
        "verify"
    ]);
    return await crypto.subtle.verify(algorithm, signingKey, Either.getOrThrow(Encoding.decodeHex(sig)), encoder.encode(payload));
};

export { ALLOWED_FILE_TYPES, BadRequestError, FILESIZE_UNITS, FetchContext, FetchError, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, InvalidFileSizeError, InvalidFileTypeError, InvalidJsonError, InvalidRouteConfigError, InvalidURLError, RetryError, UnknownFileTypeError, UploadAbortedError, UploadThingError, ValidACLs, ValidContentDispositions, allowedContentTextLabelGenerator, asArray, bytesToFileSize, capitalizeStart, contentDisposition, contentFieldToContent, exponentialDelay, fetchEff, fileSizeToBytes, fillInputRouteConfig, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getErrorTypeFromStatusCode, getFilesFromClipboardEvent, getFullApiUrl, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, parseRequestJson, parseResponseJson, resolveMaybeUrlArg, safeNumberReplacer, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature };
