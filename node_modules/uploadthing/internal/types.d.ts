import * as S from '@effect/schema/Schema';
import { Schema } from '@effect/schema/Schema';
import * as effect_Effect from 'effect/Effect';
import { Json, MaybePromise, FileRouterInputKey, ErrorMessage, FileRouterInputConfig, UploadThingError, FetchEsque, FetchContext, Simplify } from '@uploadthing/shared';
import { FileUploadDataWithCustomId, UploadedFileData } from '../types/index.js';

/**
 * All the public log levels users can set.
 */
type LogLevel = "error" | "warn" | "info" | "debug" | "trace";

/**
 * TODO: Do we wanna support effect/schema parsers now??
 */
type ParseFn<TType> = (input: unknown) => MaybePromise<TType>;
type ParserZodEsque<TInput, TParsedInput extends Json> = {
    _input: TInput;
    _output: TParsedInput;
    parse: ParseFn<TParsedInput>;
};
type JsonParser = ParserZodEsque<Json, Json>;

declare const FileUploadData_base: S.Class<FileUploadData, {
    name: typeof S.String;
    size: typeof S.Number;
    type: typeof S.String;
}, S.Struct.Encoded<{
    name: typeof S.String;
    size: typeof S.Number;
    type: typeof S.String;
}>, never, {
    readonly name: string;
} & {
    readonly size: number;
} & {
    readonly type: string;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */
/**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */
declare class FileUploadData extends FileUploadData_base {
}
declare const PresignedBase_base: S.Class<PresignedBase, {
    key: typeof S.String;
    fileName: typeof S.String;
    fileType: S.Schema<FileRouterInputKey>;
    fileUrl: typeof S.String;
    appUrl: typeof S.String;
    pollingJwt: typeof S.String;
    pollingUrl: typeof S.String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<typeof S.String>;
}, S.Struct.Encoded<{
    key: typeof S.String;
    fileName: typeof S.String;
    fileType: S.Schema<FileRouterInputKey>;
    fileUrl: typeof S.String;
    appUrl: typeof S.String;
    pollingJwt: typeof S.String;
    pollingUrl: typeof S.String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<typeof S.String>;
}>, never, {
    readonly customId: string | null;
} & {
    readonly key: string;
} & {
    readonly appUrl: string;
} & {
    readonly fileName: string;
} & {
    readonly fileUrl: string;
} & {
    readonly pollingJwt: string;
} & {
    readonly pollingUrl: string;
} & {
    readonly contentDisposition: "inline" | "attachment";
} & {
    readonly fileType: FileRouterInputKey;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */
declare class PresignedBase extends PresignedBase_base {
}
declare const MPUResponse_base: S.Class<MPUResponse, {
    key: typeof S.String;
    fileName: typeof S.String;
    fileType: S.Schema<FileRouterInputKey>;
    fileUrl: typeof S.String;
    appUrl: typeof S.String;
    pollingJwt: typeof S.String;
    pollingUrl: typeof S.String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<typeof S.String>;
} & {
    urls: S.Array$<typeof S.String>;
    uploadId: typeof S.String;
    chunkSize: typeof S.Number;
    chunkCount: typeof S.Number;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly appUrl: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
} & {} & {
    readonly uploadId: string;
    readonly chunkSize: number;
    readonly chunkCount: number;
    readonly urls: readonly string[];
} & {}, never, {
    readonly customId: string | null;
} & {
    readonly key: string;
} & {
    readonly appUrl: string;
} & {
    readonly fileName: string;
} & {
    readonly fileUrl: string;
} & {
    readonly pollingJwt: string;
} & {
    readonly pollingUrl: string;
} & {
    readonly contentDisposition: "inline" | "attachment";
} & {
    readonly fileType: FileRouterInputKey;
} & {
    readonly uploadId: string;
} & {
    readonly chunkSize: number;
} & {
    readonly chunkCount: number;
} & {
    readonly urls: readonly string[];
}, PresignedBase, {}>;
declare class MPUResponse extends MPUResponse_base {
}
declare const PSPResponse_base: S.Class<PSPResponse, {
    key: typeof S.String;
    fileName: typeof S.String;
    fileType: S.Schema<FileRouterInputKey>;
    fileUrl: typeof S.String;
    appUrl: typeof S.String;
    pollingJwt: typeof S.String;
    pollingUrl: typeof S.String;
    contentDisposition: S.Literal<["inline", "attachment"]>;
    customId: S.NullOr<typeof S.String>;
} & {
    url: typeof S.String;
    fields: S.Record$<typeof S.String, typeof S.String>;
}, {
    readonly customId: string | null;
    readonly key: string;
    readonly appUrl: string;
    readonly fileName: string;
    readonly fileUrl: string;
    readonly pollingJwt: string;
    readonly pollingUrl: string;
    readonly contentDisposition: "inline" | "attachment";
    readonly fileType: FileRouterInputKey;
} & {} & {
    readonly fields: {
        readonly [x: string]: string;
    };
    readonly url: string;
} & {}, never, {
    readonly customId: string | null;
} & {
    readonly key: string;
} & {
    readonly appUrl: string;
} & {
    readonly fileName: string;
} & {
    readonly fileUrl: string;
} & {
    readonly pollingJwt: string;
} & {
    readonly pollingUrl: string;
} & {
    readonly contentDisposition: "inline" | "attachment";
} & {
    readonly fileType: FileRouterInputKey;
} & {
    readonly fields: {
        readonly [x: string]: string;
    };
} & {
    readonly url: string;
}, PresignedBase, {}>;
declare class PSPResponse extends PSPResponse_base {
}
declare const PresignedURLResponse: S.Array$<S.Union<[typeof PSPResponse, typeof MPUResponse]>>;
declare const UploadActionPayload_base: S.Class<UploadActionPayload, {
    files: S.Array$<typeof FileUploadData>;
    input: S.Schema<Json>;
}, S.Struct.Encoded<{
    files: S.Array$<typeof FileUploadData>;
    input: S.Schema<Json>;
}>, never, {
    readonly files: readonly FileUploadData[];
} & {
    readonly input: Json;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */
declare class UploadActionPayload extends UploadActionPayload_base {
}
declare const FailureActionPayload_base: S.Class<FailureActionPayload, {
    fileKey: typeof S.String;
    uploadId: S.NullOr<typeof S.String>;
    storageProviderError: S.optional<typeof S.String>;
    fileName: typeof S.String;
}, S.Struct.Encoded<{
    fileKey: typeof S.String;
    uploadId: S.NullOr<typeof S.String>;
    storageProviderError: S.optional<typeof S.String>;
    fileName: typeof S.String;
}>, never, {
    readonly fileKey: string;
} & {
    readonly fileName: string;
} & {
    readonly uploadId: string | null;
} & {
    readonly storageProviderError?: string | undefined;
}, {}, {}>;
declare class FailureActionPayload extends FailureActionPayload_base {
}
declare const MultipartCompleteActionPayload_base: S.Class<MultipartCompleteActionPayload, {
    fileKey: typeof S.String;
    uploadId: typeof S.String;
    etags: S.Array$<S.Struct<{
        tag: typeof S.String;
        partNumber: typeof S.Number;
    }>>;
}, S.Struct.Encoded<{
    fileKey: typeof S.String;
    uploadId: typeof S.String;
    etags: S.Array$<S.Struct<{
        tag: typeof S.String;
        partNumber: typeof S.Number;
    }>>;
}>, never, {
    readonly fileKey: string;
} & {
    readonly uploadId: string;
} & {
    readonly etags: readonly {
        readonly tag: string;
        readonly partNumber: number;
    }[];
}, {}, {}>;
declare class MultipartCompleteActionPayload extends MultipartCompleteActionPayload_base {
}

/**
 * Returned by `/api/prepareUpload` and `/api/uploadFiles`
 */
type PresignedURLs = S.Schema.Type<typeof PresignedURLResponse>;
/**
 * Marker used to append a `customId` to the incoming file data in `.middleware()`
 * @example
 * ```ts
 * .middleware((opts) => {
 *   return {
 *     [UTFiles]: opts.files.map((file) => ({
 *       ...file,
 *       customId: generateId(),
 *     }))
 *   };
 * })
 * ```
 */
declare const UTFiles: unique symbol;
declare const unsetMarker: "unsetMarker" & {
    __brand: "unsetMarker";
};
type UnsetMarker = typeof unsetMarker;
type ValidMiddlewareObject = {
    [UTFiles]?: Partial<FileUploadDataWithCustomId>[];
    [key: string]: unknown;
};
type ResolverOptions<TParams extends AnyParams> = {
    metadata: Simplify<TParams["_metadata"] extends UnsetMarker ? undefined : Omit<TParams["_metadata"], typeof UTFiles>>;
    file: UploadedFileData;
};
/**
 * Different frameworks have different request and response types
 */
type MiddlewareFnArgs<TRequest, TResponse, TEvent> = {
    req: TRequest;
    res: TResponse;
    event: TEvent;
};
interface AnyParams {
    _input: any;
    _metadata: any;
    _middlewareArgs: MiddlewareFnArgs<any, any, any>;
    _errorShape: any;
    _errorFn: any;
    _output: any;
}
type MiddlewareFn<TInput extends Json | UnsetMarker, TOutput extends ValidMiddlewareObject, TArgs extends MiddlewareFnArgs<any, any, any>> = (opts: TArgs & {
    files: Schema.Type<typeof UploadActionPayload>["files"];
    input: TInput extends UnsetMarker ? undefined : TInput;
}) => MaybePromise<TOutput>;
type ResolverFn<TOutput extends Json | void, TParams extends AnyParams> = (opts: ResolverOptions<TParams>) => MaybePromise<TOutput>;
type UploadErrorFn = (input: {
    error: UploadThingError;
    fileKey: string;
}) => void;
interface UploadBuilder<TParams extends AnyParams> {
    input: <TParser extends JsonParser>(parser: TParams["_input"] extends UnsetMarker ? TParser : ErrorMessage<"input is already set">) => UploadBuilder<{
        _input: TParser["_output"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: UnsetMarker;
    }>;
    middleware: <TOutput extends ValidMiddlewareObject>(fn: TParams["_metadata"] extends UnsetMarker ? MiddlewareFn<TParams["_input"], TOutput, TParams["_middlewareArgs"]> : ErrorMessage<"middleware is already set">) => UploadBuilder<{
        _input: TParams["_input"];
        _metadata: TOutput;
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: UnsetMarker;
    }>;
    onUploadComplete: <TOutput extends Json | void>(fn: ResolverFn<TOutput, TParams>) => Uploader<{
        _input: TParams["_input"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: TOutput;
    }>;
    onUploadError: (fn: TParams["_errorFn"] extends UnsetMarker ? UploadErrorFn : ErrorMessage<"onUploadError is already set">) => UploadBuilder<{
        _input: TParams["_input"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: UploadErrorFn;
        _output: UnsetMarker;
    }>;
}
type UploadBuilderDef<TParams extends AnyParams> = {
    routerConfig: FileRouterInputConfig;
    inputParser: JsonParser;
    middleware: MiddlewareFn<TParams["_input"], {}, TParams["_middlewareArgs"]>;
    errorFormatter: (err: UploadThingError) => TParams["_errorShape"];
    onUploadError: UploadErrorFn;
};
interface Uploader<TParams extends AnyParams> {
    _def: TParams & UploadBuilderDef<TParams>;
    resolver: ResolverFn<TParams["_output"], TParams>;
}
type AnyUploader = Uploader<AnyParams>;
type FileRouter<TParams extends AnyParams = AnyParams> = Record<string, Uploader<TParams>>;
type RouteHandlerConfig = {
    logLevel?: LogLevel;
    callbackUrl?: string;
    uploadthingId?: string;
    uploadthingSecret?: string;
    /**
     * Used to determine whether to run dev hook or not
     * @default `env.NODE_ENV === "development" || env.NODE_ENV === "dev"`
     */
    isDev?: boolean;
    /**
     * Used to override the fetch implementation
     * @default `globalThis.fetch`
     */
    fetch?: FetchEsque;
};
type RouteHandlerOptions<TRouter extends FileRouter> = {
    router: TRouter;
    config?: RouteHandlerConfig;
};
type RequestHandlerInput<TArgs extends MiddlewareFnArgs<any, any, any>> = {
    req: Request | effect_Effect.Effect<Request, UploadThingError>;
    middlewareArgs: TArgs;
};
type RequestHandlerSuccess = {
    success: true;
    body: UTEvents[keyof UTEvents]["out"];
    cleanup?: Promise<unknown> | undefined;
};
type RequestHandlerError = {
    success: false;
    error: UploadThingError;
};
type RequestHandlerOutput = RequestHandlerSuccess | RequestHandlerError;
type RequestHandler<TArgs extends MiddlewareFnArgs<any, any, any>> = (input: RequestHandlerInput<TArgs>) => effect_Effect.Effect<RequestHandlerSuccess, UploadThingError, FetchContext>;
type inferEndpointInput<TUploader extends Uploader<any>> = TUploader["_def"]["_input"] extends UnsetMarker ? undefined : TUploader["_def"]["_input"];
type inferEndpointOutput<TUploader extends AnyUploader> = TUploader["_def"]["_output"] extends UnsetMarker | void | undefined ? null : TUploader["_def"]["_output"];
type inferErrorShape<TRouter extends FileRouter> = TRouter[keyof TRouter]["_def"]["_errorShape"];
/**
 * Valid options for the `?actionType` query param
 */
declare const VALID_ACTION_TYPES: readonly ["upload", "failure", "multipart-complete"];
type ActionType = (typeof VALID_ACTION_TYPES)[number];
declare const isActionType: (input: unknown) => input is ActionType;
/**
 * Valid options for the `uploadthing-hook` header
 * for requests coming from UT server
 */
declare const VALID_UT_HOOKS: readonly ["callback"];
type UploadThingHook = (typeof VALID_UT_HOOKS)[number];
declare const isUploadThingHook: (input: unknown) => input is UploadThingHook;
/**
 * Map actionType to the required payload for that action
 * @todo Look into using @effect/rpc :thinking:
 */
type UTEvents = {
    upload: {
        in: S.Schema.Type<typeof UploadActionPayload>;
        out: S.Schema.Type<typeof PresignedURLResponse>;
    };
    failure: {
        in: S.Schema.Type<typeof FailureActionPayload>;
        out: null;
    };
    "multipart-complete": {
        in: S.Schema.Type<typeof MultipartCompleteActionPayload>;
        out: null;
    };
};

export { type ActionType, type AnyParams, type AnyUploader, type FileRouter, type MiddlewareFnArgs, type PresignedURLs, type RequestHandler, type RequestHandlerError, type RequestHandlerInput, type RequestHandlerOutput, type RequestHandlerSuccess, type RouteHandlerConfig, type RouteHandlerOptions, type UTEvents, UTFiles, type UnsetMarker, type UploadBuilder, type UploadBuilderDef, type UploadThingHook, type Uploader, VALID_ACTION_TYPES, VALID_UT_HOOKS, type ValidMiddlewareObject, type inferEndpointInput, type inferEndpointOutput, type inferErrorShape, isActionType, isUploadThingHook };
